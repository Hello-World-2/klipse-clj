["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Object",["^ "],"~$confirm",["^ "]],"~:use-macros",["^ ","~$starts-with?","~$clojure.string","~$go","~$cljs.core.async.macros","~$dbg","~$gadjett.core","~$go-loop","^9","~$emits","~$cljs.compiler","~$*source-map-data*","^>","~$emit","^>"],"~:excludes",["~#set",[]],"~:name","~$klipse-clj.lang.clojure.guard","~:imports",null,"~:requires",["^ ","~$ana","~$cljs.analyzer","^H","^H","~$s","^7","^7","^7","^>","^>","~$cljs.core.async","^I"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$timeout","^I","~$<!","^I","^6","^7","~$chan","^I","^=","^>","^?","^>","^@","^>","~$put!","^I"],"~:defs",["^ ","~$watchdog",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","~:line",47,"~:column",7,"~:end-line",47,"~:end-column",15,"~:arglists",["~#list",["~$quote",["^Z",[[]]]]]],"^C","~$klipse-clj.lang.clojure.guard/watchdog","~:variadic",false,"^T","src/klipse_clj/lang/clojure/guard.cljs","^X",15,"~:method-params",["^Z",[[]]],"~:protocol-impl",null,"~:arglists-meta",["^Z",[null,null]],"^V",1,"^U",47,"^W",47,"~:max-fixed-arity",0,"~:fn-var",true,"^Y",["^Z",["^[",["^Z",[[]]]]]],"~$guard",["^ ","^R",null,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",52,"^V",3,"^W",52,"^X",8,"~:export",true,"^Y",["^Z",["^[",["^Z",[["~$max-eval-duration"]]]]]],"^C","~$klipse-clj.lang.clojure.guard/guard","^11",false,"^T","src/klipse_clj/lang/clojure/guard.cljs","^X",8,"^12",["^Z",[["^19"]]],"^13",null,"^18",true,"^14",["^Z",[null,null]],"^V",1,"^U",51,"^W",52,"^15",1,"^16",true,"^Y",["^Z",["^[",["^Z",[["^19"]]]]]],"~$tick",["^ ","^R",null,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",33,"^V",7,"^W",33,"^X",11,"^Y",["^Z",["^[",["^Z",[[]]]]]],"^C","~$klipse-clj.lang.clojure.guard/tick","^11",false,"^T","src/klipse_clj/lang/clojure/guard.cljs","^X",11,"^12",["^Z",[[]]],"^13",null,"^14",["^Z",[null,null]],"^V",1,"^U",33,"^W",33,"^15",0,"^16",true,"^Y",["^Z",["^[",["^Z",[[]]]]]],"~$runonce",["^ ","^R",null,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",26,"^V",7,"^W",26,"^X",14,"^Y",["^Z",["^[",["^Z",[["~$f"]]]]]],"^C","~$klipse-clj.lang.clojure.guard/runonce","^11",false,"^T","src/klipse_clj/lang/clojure/guard.cljs","^X",14,"^12",["^Z",[["~$f"]]],"^13",null,"^14",["^Z",[null,null]],"^V",1,"^U",26,"^W",26,"^15",1,"^16",true,"^Y",["^Z",["^[",["^Z",[["~$f"]]]]]],"~$run-watchdog*",["^ ","^R",null,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",36,"^V",7,"^W",36,"^X",20,"^Y",["^Z",["^[",["^Z",[[]]]]],"~:doc","reset the *watchdog-tick* to the current time once in a while"],"^C","~$klipse-clj.lang.clojure.guard/run-watchdog*","^11",false,"^T","src/klipse_clj/lang/clojure/guard.cljs","^X",20,"^12",["^Z",[[]]],"^13",null,"^14",["^Z",[null,null]],"^V",1,"^U",36,"^W",36,"^15",0,"^16",true,"^Y",["^Z",["^[",["^Z",[[]]]]],"^1@","reset the *watchdog-tick* to the current time once in a while"],"~$watchdog-period",["^ ","^C","~$klipse-clj.lang.clojure.guard/watchdog-period","^T","src/klipse_clj/lang/clojure/guard.cljs","^U",22,"^V",1,"^W",24,"^X",18,"^1@","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration.","^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",24,"^V",3,"^W",24,"^X",18,"^1@","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"~:tag","~$number"],"~$min-max-eval-duration",["^ ","^C","~$klipse-clj.lang.clojure.guard/min-max-eval-duration","^T","src/klipse_clj/lang/clojure/guard.cljs","^U",21,"^V",1,"^W",21,"^X",27,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",21,"^V",6,"^W",21,"^X",27],"^1D","^1E"],"~$run-watchdog-once",["^ ","^C","~$klipse-clj.lang.clojure.guard/run-watchdog-once","^T","src/klipse_clj/lang/clojure/guard.cljs","^U",45,"^V",1,"^W",45,"^X",23,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",45,"^V",6,"^W",45,"^X",23],"^1D","~$any"],"~$my-emits",["^ ","^R",null,"^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",59,"^V",7,"^W",59,"^X",15,"^Y",["^Z",["^[",["^Z",[["^19","~$&","~$xs"]]]]],"^1@","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  ","~:top-fn",["^ ","^11",true,"^15",1,"^12",[["^Z",["^19","^1L"]]],"^Y",["^Z",[["^19","~$&","^1L"]]],"^14",["^Z",[null]]]],"^C","~$klipse-clj.lang.clojure.guard/my-emits","^11",true,"^T","src/klipse_clj/lang/clojure/guard.cljs","^X",15,"^1M",["^ ","^11",true,"^15",1,"^12",[["^Z",["^19","^1L"]]],"^Y",["^Z",[["^19","~$&","^1L"]]],"^14",["^Z",[null]]],"^12",[["^Z",["^19","^1L"]]],"^13",null,"^14",["^Z",[null]],"^V",1,"^U",59,"^W",59,"^15",1,"^16",true,"^Y",["^Z",[["^19","~$&","^1L"]]],"^1@","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  "],"~$*watchdog-tick*",["^ ","^S",["^ ","^T","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^U",19,"^V",3,"^W",19,"^X",18,"^1@","each time the watchdog has a chance to run, this var is set with the current time","~:dynamic",true],"^C","~$klipse-clj.lang.clojure.guard/*watchdog-tick*","^T","src/klipse_clj/lang/clojure/guard.cljs","^X",18,"^V",1,"^1P",true,"^U",17,"^W",19,"^1D","^1E","^1@","each time the watchdog has a chance to run, this var is set with the current time"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$gadjett","^;","^;","^;","^9","^9","^I","^I"],"~:cljs.analyzer/constants",["^ ","~:seen",["^B",["~:else","~:recur","~:gen-col"]],"~:order",["^1X","^1W","^1Y"]],"^1@","The basic idea is that the first time a klipse snippet's cljs is evaluated, we kick off a go-loop whose job is to wake up every 100ms and update *watchdog-tick* to say: this is the last time that i woke up!\n\n  And if (guard) gets run and notices that the watchdog hasn't been able to wake up within the last *max-eval-duration* milliseconds, it decides that we should kill the currently evaluating function, and does that by throwing an error.\n\n  and this doesn't kill go-loops created by users' snippet code, because those go-loops won't block the watchdog from running.\n  "]